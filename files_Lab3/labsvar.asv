

% 1.1 ----------------------------------------

load('spectra.mat'); % Ladda spektraldata

R = ones(size(wavelength)); % Ideal vit yta (100% reflektans)

% Ber칛kna vitpunkten f칬r CIED65
XYZ_D65 = spectra2xyz(R, CIED65); 

% Visa resultatet
disp('Ber칛knad vitpunkt f칬r CIED65:');
disp(XYZ_D65);

% J칛mf칬r med teoretiska v칛rden
% XYZ_theoretical = [95.04, 100, 108.88]; 
% disp('Teoretiska v칛rden f칬r vitpunkten:');
% disp(XYZ_theoretical);

% Ber칛kna skillnaden mellan ber칛knade och teoretiska v칛rden
% diff = XYZ_D65 - XYZ_theoretical;
% disp('Skillnad mellan ber칛knade och teoretiska v칛rden:');
% disp(diff);

%% 1.2 ----------------------------------------------

% Ladda spektrala data
load('spectra.mat'); 

% Ber칛kna XYZ f칬r R1 och R2 under CIED65-belysning
[X_R1, Y_R1, Z_R1] = spectra2xyz(R1, CIED65);
[X_R2, Y_R2, Z_R2] = spectra2xyz(R2, CIED65);

% Visa resultaten separat
disp('XYZ-v칛rden f칬r R1 under CIED65:');
disp(['X = ', num2str(X_R1)]);
disp(['Y = ', num2str(Y_R1)]);
disp(['Z = ', num2str(Z_R1)]);

disp('XYZ-v칛rden f칬r R2 under CIED65:');
disp(['X = ', num2str(X_R2)]);
disp(['Y = ', num2str(Y_R2)]);
disp(['Z = ', num2str(Z_R2)]);

% Plotta reflektansfunktionerna
% figure;
% plot(wavelength, R1, 'b', 'LineWidth', 2); % R1 i bl친tt
% hold on;
% plot(wavelength, R2, 'r', 'LineWidth', 2); % R2 i r칬tt
% hold off;

% L칛gg till etiketter och titel
% xlabel('V친gl칛ngd (nm)');
% ylabel('Reflektans');
% title('Reflektansspektra f칬r R1 och R2');
% legend('R1', 'R2');
% grid on;

%% 1.3

% Ladda spektrala data
load('spectra.mat'); 

% Ber칛kna XYZ-v칛rden f칬r R1 och R2 under F11-belysning
[X_R1_F11, Y_R1_F11, Z_R1_F11] = spectra2xyz(R1, f11);
[X_R2_F11, Y_R2_F11, Z_R2_F11] = spectra2xyz(R2, f11);

% Visa resultaten separat
disp('XYZ-v칛rden f칬r R1 under F11:');
disp(['X = ', num2str(X_R1_F11)]);
disp(['Y = ', num2str(Y_R1_F11)]);
disp(['Z = ', num2str(Z_R1_F11)]);

disp('XYZ-v칛rden f칬r R2 under F11:');
disp(['X = ', num2str(X_R2_F11)]);
disp(['Y = ', num2str(Y_R2_F11)]);
disp(['Z = ', num2str(Z_R2_F11)]);


%% 1.4 Teorifr친ga

% Vad har h칛nt?
% N칛r belysningen 칛ndrades fr친n CIED65 till F11, f칬r칛ndrades f칛rgerna p친 objekten. 
% Vissa f칛rger blev mer m칛ttade, medan andra 칛ndrade utseende. 
% Detta beror p친 att F11 har en icke-kontinuerlig spektralf칬rdelning med endast tre smala v친gl칛ngdsband.

% Vad kallas fenomenet?
% Detta fenomen kallas metamerism. Det inneb칛r att f칛rger kan se lika ut under en ljusk칛lla men olika under en annan. 
% Eftersom F11 har en begr칛nsad spektral t칛ckning, p친verkas f칛rg친tergivningen och vissa f칛rger kan verka felaktiga eller mer m칛ttade j칛mf칬rt med dagsljus (CIED65).

%% 1.5 

% Ladda spektrala data
load('spectra.mat'); 

% XYZ-v칛rden f칬r objekten fr친n uppgift 1.2 (under CIED65)
[X_R1_CIED65, Y_R1_CIED65, Z_R1_CIED65] = spectra2xyz(R1, CIED65);
[X_R2_CIED65, Y_R2_CIED65, Z_R2_CIED65] = spectra2xyz(R2, CIED65);

% XYZ-v칛rden f칬r objekten fr친n uppgift 1.3 (under F11)
[X_R1_F11, Y_R1_F11, Z_R1_F11] = spectra2xyz(R1, f11);
[X_R2_F11, Y_R2_F11, Z_R2_F11] = spectra2xyz(R2, f11);

% Konvertera XYZ till RGB med myxyz2rgb
[R1_CIED65, G1_CIED65, B1_CIED65] = myxyz2rgb(X_R1_CIED65, Y_R1_CIED65, Z_R1_CIED65);
[R2_CIED65, G2_CIED65, B2_CIED65] = myxyz2rgb(X_R2_CIED65, Y_R2_CIED65, Z_R2_CIED65);
[R1_F11, G1_F11, B1_F11] = myxyz2rgb(X_R1_F11, Y_R1_F11, Z_R1_F11);
[R2_F11, G2_F11, B2_F11] = myxyz2rgb(X_R2_F11, Y_R2_F11, Z_R2_F11);

% Skapa en f칛rgkarta med de fyra RGB-v칛rdena
map = [
    R1_CIED65, G1_CIED65, B1_CIED65;  % R1 under CIED65
    R2_CIED65, G2_CIED65, B2_CIED65;  % R2 under CIED65
    R1_F11, G1_F11, B1_F11;           % R1 under F11
    R2_F11, G2_F11, B2_F11            % R2 under F11
];

% Klipp RGB-v칛rden s친 att de ligger inom [0,1]
map = min(1, max(0, map));

% Skapa och visa bilden med de fyra f칛rgerna
figure;
image([1 2; 3 4]);
colormap(map);
axis off;
title('F칛rg친tergivning av R1 och R2 under CIED65 och F11');

% har sparat bilden manuellt och d칬pte den till fargatergivningR1R2

%% 1.6 Teorifr친ga

% F칛rgmatchningsfunktionerna 
% 洧논(洧랝), 洧녽(洧랝) och 洧녾(洧랝) beskriver hur det m칛nskliga 칬gat uppfattar ljus vid olika v친gl칛ngder. 
% De representerar 칬gats tre tappreceptorer:

% 洧논(洧랝) motsvarar r칬d k칛nslighet.
% 洧녽(洧랝) motsvarar gr칬n k칛nslighet och best칛mmer ljushet.
% 洧녾(洧랝) motsvarar bl친 k칛nslighet.
%Dessa funktioner anv칛nds i CIEXYZ-systemet f칬r att ber칛kna tristimulusv칛rden, 
% vilket g칬r det m칬jligt att kvantifiera f칛rg matematiskt.

%% 1.7 Teorifr친ga

% CIE Y-v칛rdet f칬r en ljusk칛lla 칛r alltid 100 eftersom normaliseringsfaktorn 洧녲 i ekvation 1.4 s칛kerst칛ller detta.
% Y-v칛rdet representerar ljusstyrka, och f칬r en helt vit yta 칛r Y = 100 per definition. 
% Detta g칬r att vi kan j칛mf칬ra f칛rger och ljusk칛llor konsekvent i CIEXYZ-f칛rgsystemet.

%% 2.1

% XYZ-v칛rden fr친n tabellen
X_paper = 80.43; Y_paper = 84.00; Z_paper = 96.50;
X_cyan_magenta = 7.40; Y_cyan_magenta = 5.74; Z_cyan_magenta = 40.36;

% Dot-on-dot (50% papper, 50% cyan + magenta)------
X_on = 0.5 * X_paper + 0.5 * X_cyan_magenta;
Y_on = 0.5 * Y_paper + 0.5 * Y_cyan_magenta;
Z_on = 0.5 * Z_paper + 0.5 * Z_cyan_magenta;

disp('XYZ f칬r Dot-on-Dot:');
disp([X_on, Y_on, Z_on]);

% XYZ-v칛rden fr친n tabellen
X_cyan = 25.84; Y_cyan = 42.52; Z_cyan = 80.88;
X_magenta = 37.36; Y_magenta = 18.44; Z_magenta = 27.52;

% Dot-off-dot (50% cyan, 50% magenta) ----------
X_off = 0.5 * X_cyan + 0.5 * X_magenta;
Y_off = 0.5 * Y_cyan + 0.5 * Y_magenta;
Z_off = 0.5 * Z_cyan + 0.5 * Z_magenta;

disp('XYZ f칬r Dot-off-Dot:');
disp([X_off, Y_off, Z_off]);

%% 2.2

% Ladda spektrala data
load('spectra.mat'); 

% XYZ-v칛rden fr친n tabellen
XYZ_none = [80.43, 84.00, 96.50];
XYZ_cyan = [25.84, 42.52, 80.88];
XYZ_magenta = [37.36, 18.44, 27.52];
XYZ_cyan_magenta = [7.40, 5.74, 40.36];

% Tidigare ber칛knade v칛rden f칬r Dot-on-dot och Dot-off-dot
XYZ_dot_on = [X_on, Y_on, Z_on];
XYZ_dot_off = [X_off, Y_off, Z_off];

% Konvertera XYZ till RGB
[R_none, G_none, B_none] = myxyz2rgb(XYZ_none(1), XYZ_none(2), XYZ_none(3));
[R_cyan, G_cyan, B_cyan] = myxyz2rgb(XYZ_cyan(1), XYZ_cyan(2), XYZ_cyan(3));
[R_magenta, G_magenta, B_magenta] = myxyz2rgb(XYZ_magenta(1), XYZ_magenta(2), XYZ_magenta(3));
[R_cyan_mag, G_cyan_mag, B_cyan_mag] = myxyz2rgb(XYZ_cyan_magenta(1), XYZ_cyan_magenta(2), XYZ_cyan_magenta(3));
[R_dot_on, G_dot_on, B_dot_on] = myxyz2rgb(XYZ_dot_on(1), XYZ_dot_on(2), XYZ_dot_on(3));
[R_dot_off, G_dot_off, B_dot_off] = myxyz2rgb(XYZ_dot_off(1), XYZ_dot_off(2), XYZ_dot_off(3));

% Skapa en f칛rgkarta med de sex RGB-v칛rdena
map = [
    R_none, G_none, B_none;   % Inget tryck (Papper)
    R_cyan, G_cyan, B_cyan;   % Cyan
    R_magenta, G_magenta, B_magenta; % Magenta
    R_cyan_mag, G_cyan_mag, B_cyan_mag; % Cyan & Magenta
    R_dot_on, G_dot_on, B_dot_on; % Dot-on-dot
    R_dot_off, G_dot_off, B_dot_off % Dot-off-dot
];

% Klipp RGB-v칛rden s친 att de ligger inom [0,1]
map = min(1, max(0, map));

% Skapa och visa bilden med de sex f칛rgerna
figure;
image([1 2 3; 4 5 6]);
colormap(map);
axis off;
title('F칛rg친tergivning av tryckmetoder');
saveas(gcf, 'color_map_tryck.png')

% Finns det en m칛rkbar skillnad mellan dot-on-dot och dot-off-dot?
% Ja, dot-on-dot (f칛rg칬verlagring) 칛r m칬rkare 칛n dot-off-dot.
% Vilken 칛r m칬rkare och varf칬r?
% Dot-on-dot 칛r m칬rkare, eftersom cyan och magenta absorberar mer ljus n칛r de 칬verlappar.
% Vid dot-off-dot ligger cyan och magenta bredvid varandra, vilket reflekterar mer ljus.


%% 2.3 Teorifr친ga

% myxyz2rgb kan inte anv칛ndas i alla applikationer eftersom den antar en specifik RGB-f칛rgrymd och vitpunkt.
% Den 칛r enhetsberoende eftersom XYZ 칛r enhetsoberoende, 
% medan RGB beror p친 sk칛rmens f칛rgegenskaper. Om en annan sk칛rm eller f칛rgrymd anv칛nds (t.ex. AdobeRGB ist칛llet f칬r sRGB) kan f칛rgerna bli felaktiga utan korrekt f칛rgkalibrering.

%% 3.1

% L칛s in CMYK-halvtonbilden
[C, M, Y, K] = tiffread('halftone.tif');

% Konvertera till RGB
[R, G, B] = cmyk2rgb(C, M, Y, K);

% Visa RGB-bilden
imshowrgb(R, G, B);
title('RGB-version av halvtonbilden');

% Visa individuella CMYK-kanaler
figure;
subplot(2,2,1); imshow(C); title('Cyan');
subplot(2,2,2); imshow(M); title('Magenta');
subplot(2,2,3); imshow(Y); title('Yellow');
subplot(2,2,4); imshow(K); title('Black');

% V칛lj centrerad del av CMYK-bilden (256x256)
C1 = C(129:384,129:384);
M1 = M(129:384,129:384);
Y1 = Y(129:384,129:384);
K1 = K(129:384,129:384);

% Ber칛kna fraktionell t칛ckning med Demichel's ekvationer
fractional_coverage_test1 = Demichel_test(C1, M1, Y1, K1);

% Visa resultaten 
disp('Fraktionell t칛ckning f칬r Test 1 (centrerad sektion):');
disp(fractional_coverage_test1);

% Skiftar cyan-kanalen 10 pixlar ned친t
C2 = C(139:394,129:384); 
M2 = M(129:384,129:384);
Y2 = Y(129:384,129:384);
K2 = K(129:384,129:384);

% Ber칛kna fraktionell t칛ckning f칬r den skiftade bilden
fractional_coverage_test2 = Demichel_test(C2, M2, Y2, K2);

% Visa resultaten ( test 2 kanske fel v칛rden)
disp('Fraktionell t칛ckning f칬r Test 2 (misregistration, cyan ned친t 10 pixlar):');
disp(fractional_coverage_test2);

%% 3.2 Teorifr친ga

% Demichels ekvationer fungerar v칛l f칬r att uppskatta f칛rgt칛ckning under idealf칬rh친llanden (utan misregistration), 
% men har begr칛nsningar vid feljustering av f칛rger (misregistration).
% Vid sm친 f칬rskjutningar ger modellen fortfarande rimliga resultat, 
% men vid st칬rre f칬rskjutningar kan t칛ckningsgraderna avvika kraftigt.
%Detta beror p친 att ekvationerna antar en perfekt geometrisk rasterplacering, 
% vilket inte alltid motsvarar verkliga tryckfel och mispassning mellan f칛rgkanalerna.

%% 3.3 Teorifr친ga

% Om alla fyra tryckf칛rger hade samma rastervinkel, 
% skulle moir칠-effekter uppst친, vilket skulle skapa synliga m칬nster och f칬rs칛mra f칛rg친tergivningen.
% Demichels ekvationer skulle inte fungera korrekt i detta fall,
% eftersom de bygger p친 antagandet att f칛rgseparationerna 칛r slumpm칛ssigt distribuerade. 
% N칛r f칛rgerna 칬verlappar p친 ett f칬ruts칛gbart s칛tt vid samma vinkel, 
% blir modellen ogiltig och kan inte korrekt beskriva fraktionell t칛ckning.

%% 4.1
